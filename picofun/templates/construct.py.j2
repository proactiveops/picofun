"""CDK Construct for {{ namespace }} Lambda functions."""

# Generated by PicoFun - do not edit manually.

from pathlib import Path

from aws_cdk import (
    Duration,
    RemovalPolicy,
    Tags,
)
from aws_cdk import aws_iam as iam
from aws_cdk import aws_lambda as lambda_
from aws_cdk import aws_logs as logs
{% if auth_enabled %}from aws_cdk import aws_kms as kms
from aws_cdk import aws_ssm as ssm
{% endif %}{% if subnets|length > 0 %}from aws_cdk import aws_ec2 as ec2
{% endif %}from constructs import Construct

_MODULE_DIR = Path(__file__).resolve().parent


class {{ namespace | capitalize }}Functions(Construct):
    """L3 Construct for {{ namespace }} Lambda functions."""

    def __init__(
        self,
        scope: Construct,
        construct_id: str,
{% if auth_enabled %}        kms_key: kms.IKey | None = None,
{% endif %}{% if subnets|length > 0 %}        vpc: ec2.IVpc | None = None,
{% endif %}        **kwargs,
    ) -> None:
        super().__init__(scope, construct_id, **kwargs)

        Tags.of(self).add("generated_by", "picofun")
{% for tag in tags %}        Tags.of(self).add("{{ tag }}", "{{ tags[tag] }}")
{% endfor %}
        self._role = iam.Role(
            self,
            "LambdaRole",
            role_name="{{ iam_role_prefix }}{{ namespace }}",
            assumed_by=iam.ServicePrincipal("lambda.amazonaws.com"),
            managed_policies=[
                iam.ManagedPolicy.from_aws_managed_policy_name(
                    "service-role/AWSLambdaBasicExecutionRole"
                ),
            ],
{% if role_permissions_boundary %}            permissions_boundary=iam.ManagedPolicy.from_managed_policy_arn(
                self, "PermissionsBoundary", "{{ role_permissions_boundary }}"
            ),
{% endif %}        )
{% if subnets|length > 0 %}
        self._security_group = ec2.SecurityGroup(
            self,
            "LambdaSecurityGroup",
            security_group_name="pf-{{ namespace }}-lambdas",
            description="Security group for pf-{{ namespace }} lambda functions",
            vpc=vpc,
        )

        self._role.add_managed_policy(
            iam.ManagedPolicy.from_aws_managed_policy_name(
                "service-role/AWSLambdaENIManagementAccess"
            )
        )
{% endif %}{% if xray_tracing %}
        self._role.add_managed_policy(
            iam.ManagedPolicy.from_aws_managed_policy_name(
                "AWSXRayDaemonWriteAccess"
            )
        )
{% endif %}{% if auth_enabled %}
        if kms_key is not None:
            self._kms_key = kms_key
        else:
            self._kms_key = kms.Key(
                self,
                "KmsKey",
                description="KMS key for picorun {{ namespace }} SSM parameter encryption",
                enable_key_rotation=True,
                removal_policy=RemovalPolicy.DESTROY,
                pending_window=Duration.days(10),
            )
            kms.Alias(
                self,
                "KmsAlias",
                alias_name="alias/picorun-{{ namespace }}",
                target_key=self._kms_key,
            )

        ssm.StringParameter(
            self,
            "CredentialsParameter",
            parameter_name="/picofun/{{ namespace }}/credentials-{{ auth_scheme_type }}",
            description="Credentials for {{ auth_scheme_name }} authentication",
            string_value="{}",
            type=ssm.ParameterType.SECURE_STRING,
        )

        self._role.add_to_policy(
            iam.PolicyStatement(
                actions=["ssm:GetParameter"],
                resources=[
                    f"arn:aws:ssm:*:*:parameter/picofun/{{ namespace }}/credentials-*"
                ],
            )
        )
        self._role.add_to_policy(
            iam.PolicyStatement(
                actions=["kms:Decrypt"],
                resources=[self._kms_key.key_arn],
            )
        )
{% endif %}
        layer = lambda_.LayerVersion(
            self,
            "Layer",
            layer_version_name="{{ namespace }}",
            code=lambda_.Code.from_asset(str(_MODULE_DIR / "layer")),
            compatible_runtimes=[lambda_.Runtime.PYTHON_3_13],
            compatible_architectures=[lambda_.Architecture.ARM_64],
        )

        layers = [
{% for layer_arn in layers %}            lambda_.LayerVersion.from_layer_version_arn(
                self, "Layer{{ loop.index }}", "{{ layer_arn }}"
            ),
{% endfor %}            layer,
        ]

        self._functions: dict[str, lambda_.Function] = {}
{% for lambda_name in lambdas %}
        self._functions["{{ lambda_name }}"] = lambda_.Function(
            self,
            "Fn{{ lambda_name | replace('_', ' ') | title | replace(' ', '') }}",
            function_name="{{ namespace }}_{{ lambda_name }}",
            runtime=lambda_.Runtime.PYTHON_3_13,
            architecture=lambda_.Architecture.ARM_64,
            handler="{{ lambda_name }}.handler",
            code=lambda_.Code.from_asset(
                str(_MODULE_DIR / "lambdas"),
                exclude=["*"],
                # CDK does not support single-file assets directly; use bundling
                # or copy individual files. Here we include only this function.
            ),
            role=self._role,
            timeout=Duration.seconds(10),
            layers=layers,
{% if auth_enabled %}            environment={
                "PICORUN_CREDENTIALS_TTL": "{{ auth_ttl }}",
            },
{% endif %}{% if subnets|length > 0 %}            vpc=vpc,
            security_groups=[self._security_group],
{% endif %}{% if xray_tracing %}            tracing=lambda_.Tracing.ACTIVE,
{% endif %}        )

        # CloudWatch Log Group
        logs.LogGroup(
            self,
            "LogGroup{{ lambda_name | replace('_', ' ') | title | replace(' ', '') }}",
            log_group_name=f"/aws/lambda/{{ namespace }}_{{ lambda_name }}",
            retention=logs.RetentionDays.TWO_WEEKS,
            removal_policy=RemovalPolicy.DESTROY,
        )
{% endfor %}
    @property
    def functions(self) -> dict[str, lambda_.Function]:
        """Map of function names to Lambda Function constructs."""
        return self._functions

    @property
    def role(self) -> iam.Role:
        """IAM Role used by the Lambda functions."""
        return self._role
